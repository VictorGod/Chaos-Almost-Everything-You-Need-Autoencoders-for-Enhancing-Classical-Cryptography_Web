# Криптографическая система на основе автоэнкодера

Данная система объединяет возможности глубинного обучения (автоэнкодер) и классической криптографии (RSA‑OAEP), создавая гибридное решение, в котором латентное представление изображений используется в качестве источника энтропии для генерации криптографических ключей. Система включает динамическое экспресс-обучение перед каждой операцией шифрования/дешифрования для повышения безопасности и адаптивности.

---

## 1. Общая концепция

Основная идея системы заключается в использовании автоэнкодера для преобразования входного изображения в компактное латентное представление с высокой энтропией. Это представление затем применяется для генерации RSA‑ключей. Такой подход обеспечивает динамическую изменчивость криптографических параметров и повышенную устойчивость к атакам.

---

## 2. Архитектура системы

### 2.1 Автоэнкодер

#### Энкодер

- **Вход:**  

  Изображение размером 28×28 (одноканальное, оттенки серого) преобразуется в вектор размерности 784.

- **Структура:**  

  - **Первый слой:** Полносвязный слой с 128 нейронами, использующий функцию активации  

    $f(x) = \sin(8x) + 0.5 \cdot \tanh(4x)$

  - **Латентный слой:** Полносвязный слой из 64 нейронов, использующий ту же активацию и дополненный кастомным регуляризатором VarianceRegularizer, который вычисляет  

    $L = -\lambda \log(\mathrm{Var}(z) + \epsilon)$

  

Результатом работы энкодера является 64-мерное латентное представление, используемое для генерации криптографических ключей.

#### Декодер

- **Структура:**  

  - **Первый слой:** Полносвязный слой с 128 нейронами, дополненный BatchNormalization и функцией активации  

    $f(x) = \sin(8x) + 0.5 \cdot \tanh(4x)$

  - **Выходной слой:** Полносвязный слой с 784 нейронами, использующий сигмоидную активацию для нормализации значений в диапазоне `[0,1]` с последующим преобразованием в изображение 28×28.

> **Схема автоэнкодера:**  

> ```
> Input (28x28, 1)  --> Flatten (784)
>                --> Dense(128) + chaos_activation
>                --> Dense(64) (латентное представление) + VarianceRegularizer
>                --> Dense(128) + BatchNormalization + chaos_activation
>                --> Dense(784, activation='sigmoid') --> Reshape (28x28, 1)
> ```

### 2.2 Криптографический модуль

#### Генерация ключей

1. **Получение латентного представления:**  

   Из уникального случайного изображения (сгенерированного с использованием `os.urandom`) вычисляется латентный вектор через энкодер.

2. **Сбор энтропии:**  

   К данным автоэнкодера добавляются системные данные (например, timestamp, состояние CPU, случайные байты из `os.urandom`).

3. **Преобразование в криптографическую затравку:**  

   Объединённые данные обрабатываются с помощью PBKDF2 с алгоритмом SHA‑512 (5000 итераций) и разделяются на два блока для формирования затравок для поиска простых чисел:

   - $seed_p = H_{\mathrm{SHA256}}\big(\text{derived\_key}_{1:32} \parallel \text{"p"}\big)$

   - $seed_q = H_{\mathrm{SHA256}}\big(\text{derived\_key}_{32:} \parallel \text{"q"}\big)$

4. **Генерация простых чисел:**  

   На основании полученных затравок генерируются 2048-битные простые числа `p` и `q` (с использованием алгоритма Миллера–Рабина и проверки на простоту).

5. **Формирование ключей RSA:**  

   Вычисляются:

   - Модуль: $n = p \times q$

   - Функция Эйлера: $ \phi(n) = (p-1)(q-1)$

   - Секретная экспонента: $d \equiv e^{-1} \pmod{\phi(n)}$  

     при выборе $e = 65537$.

#### Шифрование и Дешифрование

- **Шифрование:**  

  Сообщение разбивается на блоки (до 214 байт с учетом отступов OAEP). Шифрование выполняется по схеме RSA‑OAEP с использованием SHA‑512 для генерации маски:

  $c = m^e \mod n$

  

  К зашифрованным блокам дополнительно применяется HMAC‑SHA256 для аутентификации, а итоговый результат упаковывается в ASN.1 контейнер с метаданными (версия алгоритма, идентификатор ключа, timestamp).

- **Дешифрование:**  

  Включает проверку HMAC, извлечение метаданных и применение техники *blinding*:

  1. Модификация шифротекста:  

     $c' = \big(r^e \mod n\big) \cdot c \mod n$

  2. Дешифрование:  

     $m' = (c')^d \mod n$

  3. Восстановление исходного сообщения:  

     $m = m' \cdot r^{-1} \mod n$

---

## 3. Карты хаотичности

Карты хаотичности обеспечивают высокий уровень энтропии для генерации обучающих данных автоэнкодера и криптографической затравки. В системе используются следующие отображения:

### 3.1 Логистическое отображение

**Формула:**  

$x_{n+1} = r \cdot x_n \cdot (1 - x_n)$

- **Параметры:**  

  Используется $r = 3.99$ для обеспечения хаотического режима.

- **Применение:**  

  Функция `generate_logistic_map_image` генерирует последовательность значений, которая затем формируется в двумерное изображение (например, 28×28).

- **Особенности:**  

  Высокая чувствительность к начальному значению $x_0$ гарантирует, что малейшее изменение приводит к сильно отличающемуся изображению (эффект лавины).

### 3.2 Отображение Арнольда ("Arnold Cat Map")

**Формулы:**  

Для изображения $N \times N$ координаты `(x, y)` преобразуются следующим образом:

- $x' = (2x + y) \mod N$

- $y' = (x + y) \mod N$

- **Применение:**  

  Функция `arnold_cat_map` перемешивает пиксели изображения, что усиливает хаотичные свойства входных данных без потери общих статистических характеристик.

- **Особенности:**  

  Отображение Арнольда значительно изменяет визуальное представление изображения, повышая устойчивость системы к анализу входных данных.

### 3.3 Роль хаотических карт в системе

- **Генерация обучающих данных:**  

  Использование хаотических карт позволяет создавать разнообразные обучающие примеры с контролируемым уровнем энтропии для динамического дообучения автоэнкодера.

- **Случайная инициализация:**  

  Хаотические карты обеспечивают псевдослучайную инициализацию весов нейронной сети, увеличивая непредсказуемость латентного представления.

- **Модификация весов:**  

  После стандартного градиентного шага веса дополнительно преобразуются по формуле:  

  $W' = W + \alpha \cdot \sin(\beta \cdot W \cdot t)$,  

  где $\alpha = 0.01$, $\beta = 0.1$ и $t$ — текущее время в миллисекундах.

---

## 4. Динамическое дообучение

Перед каждой операцией шифрования/дешифрования выполняется быстрое дообучение автоэнкодера на новых данных:

### 4.1 Процесс дообучения

1. **Генерация обучающих примеров:**  

   Создаются хаотические изображения (2–5) с использованием текущего времени, системных метрик и случайных данных.

2. **Скоростное дообучение:**  

   Проводится 1–3 эпохи обучения с повышенным темпом обучения (0.01) и модифицированным оптимизатором Adam, чувствительным к временным параметрам.

3. **Слой шума:**  

   В процессе обучения добавляется Gaussian Noise с параметрами $\mu = 0$, $\sigma = 0.25$ для повышения устойчивости к возмущениям и аналитическим атакам.

### 4.2 Влияние на безопасность

- **Временная привязка:**  

  Каждое обновление автоэнкодера связано с конкретным моментом времени, что усложняет прогнозирование его поведения.

- **Уникальность для каждой сессии:**  

  Даже при одинаковом входном изображении разные сессии шифрования создают разные ключи из-за динамического дообучения.

- **Устойчивость к обратной инженерии:**  

  Скоростное обучение на хаотических примерах гарантирует вариативность весов при сохранении общей структуры модели.

---

## 5. Анализ производительности

Ключевые метрики производительности системы:

| Метрика | Измеренные значения | Стандартные значения | Статус | Комментарий |
|---------|--------------|----------------------------|--------|-------------|
| **Время генерации ключей (RSA‑2048)** | 0.838 сек | 0.1–0.3 сек | ⚠️ | В 3–8 раз медленнее; улучшено по сравнению с предыдущей версией (0.944 сек), но требует дальнейшей оптимизации. |
| **Время шифрования** | <0.001 сек | 0.1–0.5 мс | ✅ | Результат из `test_encryption_benchmark`. Эффективно для асимметричного шифрования. |
| **Время дешифрования** | 0.100 сек | 2–5 мс | ⚠️ | Задержка из-за применения `secure_decrypt` ограничивает производительность. |
| **Энтропия шифротекста** | 7.583 бит/байт | >7.5 бит/байт | ✅ | Близко к идеалу (8 бит/байт), подтверждено тестами. |
| **Размер ключа** | 2048 бит | Минимум 2048 бит (NIST) | ✅ | Подтверждено тестом `test_quantum_resistance`; минимально приемлемо. |
| **Алгоритм паддинга** | OAEP | OAEP (NIST SP 800-56B) | ✅ | Стандартный выбор, обеспечивает безопасность. |
| **Источник энтропии** | Автоэнкодер + хаотичность + urandom | DRBG (NIST SP 800-90A) | ⚠️ | Хаотические карты и кастомная активация усиливают энтропию, но требуется дополнительный криптоанализ. |
| **Стойкость к квантовым вычислениям** | RSA‑2048 (уязвим) | RSA‑2048 – уязвим | ⚠️ | RSA неустойчив к квантовым атакам; ограничение по времени стойкости соответствует ожиданиям. |
| **Временная стойкость** | До 2028–2033 гг. | До 2028–2033 гг. | ✅ | Ограничено самим RSA, но хаотичность может улучшить перспективы. |
| **MSE (первичное обучение)** | 0.1173 (val_loss) | 0.02–0.10 | ⚠️ | Высокая ошибка из-за вариативных начальных условий хаотических карт. |
| **MSE (дообучение на хаотичности)** | 0.122661 | 0.02–0.10 | ⚠️ | Слабая адаптация к новым хаотическим данным (`dynamic_retraining_with_chaos_maps`). |
| **MSE (дообучение на случайных изображениях)** | 0.090667 | 0.02–0.10 | ✅ | Значительное улучшение по сравнению с предыдущей версией (0.136627), данные `dynamic_retraining_test`. |
| **Евклидово расстояние в латентном пространстве** | 8.978 | >0.5 | ✅ | Значительный рост (данные `test_latent_variation`), указывает на высокое разнообразие представлений. |
| **Эффект лавины** | 1.756 | – | ✅ | Высокая чувствительность к изменениям (данные `test_avalanche_effect`), значительно выше предыдущих показателей. |
| **Хаотическое расхождение** | 9.320 (конец) vs 10.827 (начало) | Ожидается >5× начальное значение (≈54.134) | ⚠️ | Хаотичность присутствует, но не достигает ожидаемого масштабирования (`test_latent_chaos_behavior`). |
| **Время дообучения (хаотичность)** | 1.305 сек | Зависит от архитектуры | ✅ | Для экспериментальных целей приемлемо. |
| **Время дообучения (случайные изображения)** | 1.289 сек | Зависит от архитектуры | ✅ | Приемлемый показатель для исследований. |
| **Статистическая случайность** | 7.592 бит/байт | >7.5 бит/байт | ✅ | Высокая энтропия шифротекста, близкая к стандарту (`test_statistical_randomness`). |
| **Устойчивость к адверсариальным атакам** | 0.204 | >0.05 | ✅ | Значительное улучшение (данные `test_adversarial_attack_resilience`). |
| **Стабильность времени дешифрования** | std = 0.000 сек | <0.05 сек | ✅ | Защита от утечек по времени подтверждена (`test_side_channel_timing_constancy`). |
| **Масштабируемость** | Успешно (20 ключей) | Отсутствие ошибок | ✅ | Параллельная генерация ключей стабильна (`test_stress_scalability`). |
| **Долговременная стабильность** | Финальный loss 0.066145 vs начальный 0.093471 | <1.5× начального | ✅ | Потери уменьшаются при дообучении (`test_long_term_stability`). |
| **Безопасная интеграция** | Успешно | Без ошибок | ✅ | Компоненты системы работают корректно (`test_safe_integration`). |
| **Изолированная среда** | Loss < 0.1 | <0.1 | ✅ | Система демонстрирует стабильность в изолированной среде (`test_isolation_environment`). |
| **Объяснимость (дисперсия латентного пространства)** | Множество значений < 0.0001 | >0.0001 для всех измерений | ⚠️ | Низкая вариативность некоторых размерностей, не решенная регуляризацией (`test_explainability_interpretability`). |

---

## 6. Заключение

Система демонстрирует инновационный подход, объединяя автоэнкодер с динамическим обучением и классическую RSA‑OAEP криптографию. Основные сильные стороны:

- Высокая энтропия шифротекста (около 7.583 бит/байт);

- Значительное улучшение эффекта лавины (1.756), что указывает на высокую чувствительность латентного представления;

- Высокое разнообразие латентного пространства (евклидово расстояние 8.978);

- Стабильность и масштабируемость системы согласно модульным тестам.

В то же время, существуют проблемы с производительностью генерации ключей и дешифрования, а также недостаточная динамика хаотического расхождения и низкая объяснимость некоторых размерностей латентного пространства.

---

## 7. Инструкции по запуску и интеграции

- **Язык:** Python  

- **Основные библиотеки:** TensorFlow, Keras, cryptography, gmpy2, psutil  

- **Запуск:**  

  Для выполнения основного скрипта выполните:

  ```bash
  python -m venv venv
  venv\Scripts\activate
  pip install -r requirements.txt
  uvicorn app.main:app --reload
  ```

- **Документация кода:**  

  В исходном коде содержатся подробные комментарии, описывающие функциональные блоки и алгоритмические решения. 
# Chaos-Almost-Everything-You-Need-Autoencoders-for-Enhancing-Classical-Cryptography_Web
